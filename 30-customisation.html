<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Customisation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="10-features.html"><div class="inner"><span>Features</span></div></a></li><li class="depth-1 "><a href="20-installation.html"><div class="inner"><span>Installation</span></div></a></li><li class="depth-1 "><a href="25-usage.html"><div class="inner"><span>Basic usage</span></div></a></li><li class="depth-1  current"><a href="30-customisation.html"><div class="inner"><span>Customisation</span></div></a></li><li class="depth-1 "><a href="40-diagnostics-and-logging.html"><div class="inner"><span>Diagnostics and Logging</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>limabean</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>harvest</span></div></div></li><li class="depth-3"><a href="limabean.harvest.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>contrib</span></div></div></li><li class="depth-5 branch"><a href="limabean.harvest.api.contrib.first-direct.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>first-direct</span></div></a></li><li class="depth-5"><a href="limabean.harvest.api.contrib.kiwibank-ofx1.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kiwibank-ofx1</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#customisation" id="customisation"></a>Customisation</h1>
<p>As described in <a href="10-features.html">features</a>, the import process is in two phases.</p>
<ol>
<li>
<p>Hulling</p>
</li>
<li>
<p>Realization</p>
</li>
</ol>
<h2><a href="#hulling" id="hulling"></a>Hulling</h2>
<p>Hulling is responsible for reading the import file into an intermediate format, where each transaction is represented as a Clojure map.  This uses an external program, and more may be provided.</p>
<p>So far two hulling programs are provided:</p>
<ul>
<li><code>hull-csv</code> for generic CSV</li>
<li><code>hull-ofx</code> for OFX (with currently only OFX1 being supported).</li>
</ul>
<p>Hulling produces both a header and a list of transactions.</p>
<p>Selection of which hulling program to run and how is called classification, and is done on the basis of a path glob in the EDN config, for example:</p>
<pre><code>{
  :id :kiwibank-ofx1,
  :selector {:path-glob "**kiwibank/*.ofx"
  :ingester ["hull-ofx" :path],
  :hdr {:dialect "kiwibank.ofx1"},

}
</code></pre>
<p><code>:id</code> simply identifies the classifier.</p>
<p><code>:selector</code> is what triggers this classifier to be selected.</p>
<p><code>:ingester</code> is a command invocation, where <code>:path</code> is substituted by the import path of the file in question.</p>
<p><code>:hdr</code> is optional, and supplements any header fields output by the hulling program in question.  These header fields are used for selection of which realizer to apply.</p>
<p>Classifiers are matched in order, so if there are multiple matches, the first one wins.</p>
<h2><a href="#realization" id="realization"></a>Realization</h2>
<p>The second phase, realization, formats these intermediate transactions into Beancount format, and is defined by mapping from whichever fields have been extracted from the import and the standard fields, which are as follows.</p>
<ul>
<li><code>:accid</code> - account ID, expected to match metadata <code>accid</code> for an <code>open</code> directive in the context file</li>
<li><code>:cur</code> - currency</li>
<li><code>:date</code> - date, in format to be specified</li>
<li><code>:narration</code></li>
<li><code>:payee</code></li>
<li><code>:txnid</code></li>
<li><code>:units</code></li>
</ul>
<h3><a href="#field-mapping" id="field-mapping"></a>Field mapping</h3>
<p>Fields may be extracted from any header or transaction field.  Type and date format must also be specified.  Type is optionally one of <code>:decimal</code> or <code>:date</code>, with omission meaning string.  Dates require an additional <code>:fmt</code> parameter, which is as defined in Java <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns"><code>DateTimeFormatter.ofPattern</code></a>.</p>
<p>For example, here is a fragment of the EDN config to extract transactions from OFX1:</p>
<pre><code>{
     :txn {:accid {:src :hdr, :key :acctid},
           :cur {:src :hdr, :key :curdef},
           :date {:src :txn, :key :dtposted, :type :date, :fmt "yyyyMMdd"},
           :narration {:src :txn, :key :memo},
           :payee {:src :txn, :key :name},
           :txnid [{:src :hdr, :key :acctid} "." {:src :txn, :key :fitid}],
           :units {:src :txn, :key :trnamt, :type :decimal}},
}
</code></pre>
<p>In this example:</p>
<ul>
<li>the <code>:accid</code> field is extracted from the header field <code>:acctid</code>.</li>
<li>the <code>:narration</code> field is extracted from the transaction field <code>:memo</code>.</li>
<li>the <code>:date</code> field, of type <code>:date</code> and format <code>"yyyyMMdd"</code>, es extracted from the transaction field <code>:dtposted</code>.</li>
<li>the <code>:txnid</code> field is a composite, the concatenation of header field <code>:acctid</code> and transaction field <code>:fitid</code>, with a separator of <code>"."</code>.</li>
<li>the <code>:units</code> field is extracted from the transaction field <code>:trnamt</code> and is of type <code>:decimal</code>.</li>
</ul>
<p>None of the field names are magical, so types must be explicitly annotated, except the default type of string.</p>
<p>After this extraction/mapping process, an arbitrary list of functions may be applied to the result.  There are some library functions available, with more to be collated.</p>
<h3><a href="#realizer-selection-and-inheritance" id="realizer-selection-and-inheritance"></a>Realizer selection and inheritance</h3>
<p>The realizer is selected on the basis of matching header fields from phase 1, in order as with classifiers.  Usually the <code>:dialect</code> passed explicitly into Phase 1 is enough.  For example,</p>
<pre><code>{
  :base :generic-ofx1,
  :id :kiwibank-ofx1,
  :selector {:dialect "kiwibank.ofx1"},
  :txn-fns [limabean.harvest.api.contrib.kiwibank-ofx1/clean-payee-narration]
}
</code></pre>
<p>In this example, the <code>:kiwibank-ofx1</code> realizer is based on the already-defined <code>:generic-ofx1</code> realizer, with a single additional function to customize the mapping of the transaction fields after base realization.</p>
<p>A realizer may be defined relative to one <em>earlier in the list of realizers</em>, by referencing its <code>id</code> in the field <code>:base</code>.  This is useful for customizing OFX import in minor ways without repeating most of the mapping.</p>
<h3><a href="#csvs-inferred-accids-and-balances" id="csvs-inferred-accids-and-balances"></a>CSVs, inferred accids, and balances</h3>
<p>A generic CSV realizer is not possible, and therefore realizers for CSV format are entirely institution-specific, for example for the British bank First direct:</p>
<pre><code>{
  :bal {:accid {:src :hdr, :key :inferred-accid},
        :cur {:src :hdr, :key :cur},
        :date {:src :txn, :key :date, :type :date, :fmt "dd/MM/yyyy"},
        :units {:src :txn, :key :balance, :type :decimal}},
  :bal-fns [limabean.harvest.api/inc-date],
  :id :first-direct-csv,
  :selector {:dialect "first-direct.csv"},
  :txn {:accid {:src :hdr, :key :inferred-accid},
        :cur {:src :hdr, :key :cur},
        :date {:src :txn, :key :date, :type :date, :fmt "dd/MM/yyyy"},
        :description {:src :txn, :key :description},
        :units {:src :txn, :key :amount, :type :decimal}},
  :txn-fns [limabean.harvest.api.contrib.first-direct/payee-narration]
}
</code></pre>
<p>Note that this example illustrates two further points which have not yet been described.</p>
<ol>
<li>
<p>The header field <code>:inferred-accid</code> is generated before realization and available for use if the import path contains any of the account IDs defined in <code>accid</code> metadata in <code>open</code> directives in the context file.  In general this is only required if there is no account ID available from hulling.</p>
</li>
<li>
<p>A balance directive may be generated from either the header or individual transactions.  In case of the latter, only the last balance is retained.  (Here the <code>inc-date</code> function is used to push the balance onto the next day, since Beancount balance directives apply to the beginning of the day.)</p>
</li>
</ol>
<h3><a href="#user-provided-code" id="user-provided-code"></a>User provided code</h3>
<p>The user may provide their realizer functions via <code>$LIMABEAN_HARVEST_USER_CLJ</code>, for example:</p>
<pre><code>(ns local
  (:require [clojure.string :as str]))

(defn lowercase-payee
  "Example realizer function to lowercase the payee.  Use in EDN config as local/lowercase-payee"
  [txn]
  (cond-&gt; txn
    (:payee txn) (update :payee str/lower-case)))
</code></pre>
<p>used like this in the EDN config file:</p>
<pre><code>{
     :txn-fns [local/lowercase-payee]}
}
</code></pre>
<h2><a href="#configuration" id="configuration"></a>Configuration</h2>
<p>The configuration is defined in EDN, passed on the command line with <code>--config</code> or via the environment variable <code>LIMABEAN_HARVEST_CONFIG</code> (with the command line flag taking priority), and is merged with the <a href="../src/limabean/harvest/core/config.clj">default configuration</a> in the following way:</p>
<ul>
<li>classifiers from default config are appended to those in user config, so applied as a fallback</li>
<li>realizers from default config are prepended to those in user config, so may be used as a base</li>
<li>output is deep merged, so individual values may be overridden while keeping the others</li>
</ul>
<p>See, for example, the <a href="../../test-cases/harvest.edn">configuration used for the tests</a>.</p>
</div></div></div></body></html>